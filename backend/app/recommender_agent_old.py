from pydantic_ai import Agent
import requests
from dotenv import load_dotenv
import nest_asyncio
import os
import logging
import time
from pydantic import BaseModel
from typing import List, Any
from utils.search_tools import search_movies_langsearch
from backend.app.profiler_test import Profile


load_dotenv()

# Configuration du logging pour le debugging
LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO').upper()
LOG_TO_FILE = os.getenv('LOG_TO_FILE', 'false').lower() == 'true'

handlers = [logging.StreamHandler()]
if LOG_TO_FILE:
    handlers.append(logging.FileHandler('agent.log'))

logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=handlers
)
logger = logging.getLogger(__name__)

logger.info(f"üîß Logging configured: Level={LOG_LEVEL}, File={LOG_TO_FILE}")
nest_asyncio.apply()

api_key = os.getenv('GEMINI_API_KEY')
LANGSEARCH_ENDPOINT = "https://api.langsearch.com/v1/web-search"
LANGSEARCH_API_KEY = os.getenv("LANGSEARCH_API_KEY")
TMDB_API_KEY = os.getenv("TMDB_API_KEY")
TMDB_BASE_URL = "https://api.themoviedb.org/3"

# Classe pour l'output de l'agent (sans poster_path)
class AgentMovie(BaseModel):
    title: str
    year: str = ""
    genre: str = ""
    director: str = ""
    description: str = ""
    why_recommended: str
    rating: str = ""
    cast: list[str] = []

class AgentMovies(BaseModel):
    movies: list[AgentMovie]

# Classe finale avec poster_path (apr√®s enrichissement TMDB)
class Movie(BaseModel):
    title: str
    year: str = ""
    genre: str = ""
    director: str = ""
    description: str = ""
    why_recommended: str
    rating: str = ""
    cast: list[str] = []
    poster_path: str = ""

class Movies(BaseModel):
    movies: list[Movie]


def search_movie_poster_tmdb(title: str, year: str = "") -> str:
    """
    Recherche le poster d'un film via l'API TMDB
    
    Args:
        title: Titre du film
        year: Ann√©e du film (optionnel)
    
    Returns:
        str: URL compl√®te du poster ou cha√Æne vide si non trouv√©
    """
    logger.info(f"üé¨ TMDB POSTER SEARCH: '{title}' ({year})")
    
    try:
        # Recherche du film sur TMDB
        search_url = f"{TMDB_BASE_URL}/search/movie"
        params = {
            "api_key": TMDB_API_KEY,
            "query": title,
            "language": "fr-FR"
        }
        
        if year:
            params["year"] = year
        
        logger.debug(f"üì§ TMDB Search Request: {search_url}")
        logger.debug(f"üì§ Params: {params}")
        
        response = requests.get(search_url, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        results = data.get("results", [])
        
        if results:
            # Prendre le premier r√©sultat
            movie = results[0]
            poster_path = movie.get("poster_path")
            
            if poster_path:
                full_poster_url = f"https://image.tmdb.org/t/p/w500{poster_path}"
                logger.info(f"‚úÖ TMDB Poster found: {full_poster_url}")
                return full_poster_url
            else:
                logger.info(f"‚ö†Ô∏è TMDB: No poster found for '{title}'")
        else:
            logger.info(f"‚ö†Ô∏è TMDB: No results found for '{title}'")
            
    except Exception as e:
        logger.error(f"‚ùå TMDB Error for '{title}': {str(e)}")
    
    return ""

def convert_agent_movies_to_movies(agent_movies: AgentMovies) -> Movies:
    """
    Convertit les films de l'agent en films enrichis avec les posters TMDB
    
    Args:
        agent_movies: R√©sultats de l'agent sans posters
    
    Returns:
        Movies: Films enrichis avec les posters TMDB
    """
    logger.info(f"üé® ENRICHING {len(agent_movies.movies)} MOVIES WITH TMDB POSTERS")
    enriched_movies = []
    
    for agent_movie in agent_movies.movies:
        logger.info(f"üîç Searching poster for: {agent_movie.title} ({agent_movie.year})")
        poster_url = search_movie_poster_tmdb(agent_movie.title, agent_movie.year)
        
        # Cr√©er un nouveau film avec le poster
        enriched_movie = Movie(
            title=agent_movie.title,
            year=agent_movie.year,
            genre=agent_movie.genre,
            director=agent_movie.director,
            description=agent_movie.description,
            why_recommended=agent_movie.why_recommended,
            rating=agent_movie.rating,
            cast=agent_movie.cast,
            poster_path=poster_url
        )
        enriched_movies.append(enriched_movie)
    
    logger.info(f"‚úÖ ENRICHMENT COMPLETE - {len(enriched_movies)} movies with posters")
    
    # Log des films enrichis
    for i, movie in enumerate(enriched_movies, 1):
        logger.debug(f"  {i}. {movie.title} ({movie.year}) - {movie.genre}")
        logger.debug(f"     Poster: {'‚úÖ' if movie.poster_path else '‚ùå'}")
    
    return Movies(movies=enriched_movies)

def get_movie_recommendations_from_profile(user_profile: Profile, query: str | None = None) -> Movies:
    """
    Fonction qui prend un profil utilisateur et retourne des recommandations de films personnalis√©es.
    
    Args:
        user_profile: Profil cin√©matographique de l'utilisateur
        query: Requ√™te optionnelle pour personnaliser la recherche
    
    Returns:
        Movies: R√©sultat de l'agent contenant la liste des films recommand√©s avec posters
    """
    logger.info(f"üé¨ STARTING PROFILE-BASED RECOMMENDATION PROCESS")

    logger.info(f"üé≠ Favorite genres: {user_profile.favorite_genres}")
    logger.info(f"üé¨ Favorite directors: {user_profile.favorite_directors}")
    logger.info(f"üí≠ Custom query: {query}")
    
    # Cr√©er l'agent avec un prompt sp√©cialis√© pour les profils utilisateur
    agent = Agent(
        'gemini-2.0-flash',
        output_type=AgentMovies,
        tools=[search_movies_langsearch],
        system_prompt="""Tu es un expert en recommandations cin√©matographiques personnalis√©es. Tu analyses le profil d√©taill√© d'un utilisateur pour sugg√©rer des films parfaitement adapt√©s √† ses go√ªts.

Tu utilises toutes les informations du profil utilisateur :
- Genres pr√©f√©r√©s et √† explorer
- R√©alisateurs et acteurs favoris
- D√©cennies pr√©f√©r√©es
- Traits de personnalit√© cin√©matographique
- Pr√©f√©rences d'ambiance de visionnage
- Description du go√ªt cin√©matographique

Pour chaque recommandation, tu expliques pr√©cis√©ment pourquoi ce film correspond au profil de l'utilisateur.
Tu donneras au moins 5 suggestions vari√©es mais coh√©rentes avec le profil.
Utilise l'outil de recherche si n√©cessaire pour enrichir tes recommandations avec des informations actualis√©es."""
    )
    
    # Construire la requ√™te bas√©e sur le profil
    profile_summary = f"""
Profil de {user_profile.user_name} :
- Genres favoris : {', '.join(user_profile.favorite_genres) if user_profile.favorite_genres else 'Non sp√©cifi√©s'}
- R√©alisateurs favoris : {', '.join(user_profile.favorite_directors) if user_profile.favorite_directors else 'Non sp√©cifi√©s'}
- Acteurs favoris : {', '.join(user_profile.favorite_actors) if user_profile.favorite_actors else 'Non sp√©cifi√©s'}
- D√©cennies pr√©f√©r√©es : {', '.join(user_profile.preferred_decades) if user_profile.preferred_decades else 'Non sp√©cifi√©es'}
- Pr√©f√©rences cin√©matographiques : {user_profile.movie_preferences}
- Traits de personnalit√© : {user_profile.personality_traits}
- Description du go√ªt : {user_profile.cinematic_taste_description}
- Genres √† explorer : {', '.join(user_profile.recommended_genres_to_explore) if user_profile.recommended_genres_to_explore else 'Non sp√©cifi√©s'}
- Pr√©f√©rences d'ambiance : {', '.join(user_profile.viewing_mood_preferences) if user_profile.viewing_mood_preferences else 'Non sp√©cifi√©es'}
"""
    
    if query:
        user_query = f"{profile_summary}\n\nRequ√™te sp√©cifique : {query}\n\nBas√© sur ce profil d√©taill√©, recommande des films parfaitement adapt√©s."
    else:
        user_query = f"{profile_summary}\n\nBas√© sur ce profil cin√©matographique d√©taill√©, recommande des films qui correspondent parfaitement aux go√ªts et √† la personnalit√© de cet utilisateur."
    
    logger.info(f"ü§ñ Sending profile-based query to Gemini AI")
    logger.debug(f"üìù Profile summary: {profile_summary[:200]}...")
    
    # Lancer l'agent et r√©cup√©rer les r√©sultats
    start_time = time.time()
    result = agent.run_sync(user_query)
    end_time = time.time()
    
    logger.info(f"‚è±Ô∏è Total AI Processing Time: {end_time - start_time:.2f}s")
    logger.info(f"‚úÖ AGENT COMPLETE - Generated {len(result.output.movies)} profile-based recommendations")
    
    # Log des recommandations de l'agent
    for i, movie in enumerate(result.output.movies, 1):
        logger.debug(f"  {i}. {movie.title} ({movie.year}) - {movie.genre}")
        logger.debug(f"     Why: {movie.why_recommended[:100]}...")
    
    # Convertir et enrichir avec les posters TMDB
    return convert_agent_movies_to_movies(result.output)

# Fonction de compatibilit√© (garde l'ancienne fonction pour la r√©trocompatibilit√©)
def get_movie_recommendations(liked_movies: list[str], query: str | None = None) -> Movies:
    """
    Fonction de compatibilit√© - utilise l'ancienne m√©thode bas√©e sur une liste de films.
    DEPRECATED: Utilisez get_movie_recommendations_from_profile() √† la place.
    """
    logger.warning("‚ö†Ô∏è DEPRECATED: get_movie_recommendations() is deprecated. Use get_movie_recommendations_from_profile() instead.")
    
    # Cr√©er l'agent avec le prompt personnalis√©
    agent = Agent(
        'gemini-2.0-flash',
        output_type=AgentMovies,
        tools=[search_movies_langsearch],
        system_prompt="""Tu es un assistant de cin√©ma qui sugg√®re des films bas√©s sur les pr√©f√©rences de l'utilisateur. 

Pour chaque suggestion de film, tu expliques pourquoi tu le sugg√®res. Tu donneras au moins 3 suggestions. 
Utilise les informations trouv√©es via l'outil de recherche pour enrichir tes recommandations."""
    )
    
    # Construire la requ√™te
    if query:
        user_query = f"Voici les films que j'aime : {', '.join(liked_movies)}. {query}"
    else:
        user_query = f"Voici les films que j'aime : {', '.join(liked_movies)}. Peux-tu me sugg√©rer des films similaires ?"
    
    logger.info(f"ü§ñ Sending query to Gemini AI: '{user_query}'")
    
    # Lancer l'agent et r√©cup√©rer les r√©sultats
    start_time = time.time()
    result = agent.run_sync(user_query)
    end_time = time.time()
    
    logger.info(f"‚è±Ô∏è Total AI Processing Time: {end_time - start_time:.2f}s")
    logger.info(f"‚úÖ AGENT COMPLETE - Generated {len(result.output.movies)} recommendations")
    
    # Convertir et enrichir avec les posters TMDB
    return convert_agent_movies_to_movies(result.output)

# Exemple d'utilisation
if __name__ == "__main__":
    from backend.app.profiler_test import create_user_profile
    
    print("üé¨ D√âMONSTRATION DE L'INT√âGRATION PROFILE_MAKER + RECOMMENDER_AGENT")
    print("=" * 70)
    
    # √âtape 1: Cr√©er un profil utilisateur √† partir de films favoris
    print("\nüìù √âTAPE 1: Cr√©ation du profil utilisateur")
    favorite_movies = ["The Godfather", "Pulp Fiction", "The Dark Knight"]
   
    
    print(f"Films favoris de {user_name}: {', '.join(favorite_movies)}")
    print("üîÑ Cr√©ation du profil en cours...")
    
    try:
        user_profile = create_user_profile(favorite_movies, user_name)
        print("‚úÖ Profil cr√©√© avec succ√®s!")
        
        # Afficher un r√©sum√© du profil
        print(f"\nüë§ PROFIL DE {user_profile.user_name.upper()}:")
        print(f"üé≠ Genres favoris: {', '.join(user_profile.favorite_genres[:3])}{'...' if len(user_profile.favorite_genres) > 3 else ''}")
        print(f"üé¨ R√©alisateurs favoris: {', '.join(user_profile.favorite_directors[:2])}{'...' if len(user_profile.favorite_directors) > 2 else ''}")
        print(f"üí≠ Traits: {user_profile.personality_traits[:100]}...")
        
        # √âtape 2: G√©n√©rer des recommandations bas√©es sur le profil
        print(f"\nüéØ √âTAPE 2: G√©n√©ration de recommandations personnalis√©es")
        print("üîÑ Analyse du profil et recherche de films adapt√©s...")
        
        recommendations = get_movie_recommendations_from_profile(user_profile)
        
        print(f"‚úÖ {len(recommendations.movies)} recommandations g√©n√©r√©es!")
        
        # Afficher les r√©sultats
        print(f"\nüé¨ FILMS RECOMMAND√âS POUR {user_profile.user_name.upper()}:")
        print("=" * 50)
        
        for i, movie in enumerate(recommendations.movies, 1):
            print(f"\n{i}. üé≠ {movie.title} ({movie.year})")
            print(f"   üìÇ Genre: {movie.genre}")
            if movie.director:
                print(f"   üé¨ R√©alisateur: {movie.director}")
            print(f"   üí° Pourquoi recommand√©: {movie.why_recommended}")
            if movie.cast:
                print(f"   ‚≠ê Cast: {', '.join(movie.cast[:3])}{'...' if len(movie.cast) > 3 else ''}")
            if movie.poster_path:
                print(f"   üñºÔ∏è Poster: ‚úÖ")
            print("   " + "-" * 40)
        
        print(f"\nüéâ D√âMONSTRATION TERMIN√âE AVEC SUCC√àS!")
        print("‚úÖ Le syst√®me profile_maker + recommender_agent fonctionne parfaitement!")
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la d√©monstration: {str(e)}")
        print("\nüîÑ Utilisation de l'ancienne m√©thode comme fallback...")
        
        # Fallback vers l'ancienne m√©thode
        recommendations = get_movie_recommendations(favorite_movies)
        
        print("Films recommand√©s (m√©thode classique):")
        for movie in recommendations.movies:
            print(f"\n- {movie.title} ({movie.year})")
            print(f"  Genre: {movie.genre}")
            print(f"  R√©alisateur: {movie.director}")
            print(f"  Pourquoi recommand√©: {movie.why_recommended}")
